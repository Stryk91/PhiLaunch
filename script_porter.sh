#!/bin/bash
#
# Script Porter v1.0
# Cross-platform script converter
# Converts between .bat (Windows), .ps1 (PowerShell), and .sh (Unix/Mac)
#
# Usage: ./script_porter.sh <input_script> [output_format]
#

set -e

VERSION="1.0.0"
SCRIPT_NAME=$(basename "$0")

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_banner() {
    echo -e "${GREEN}"
    echo "========================================"
    echo "   SCRIPT PORTER v${VERSION}"
    echo "   Cross-Platform Script Converter"
    echo "========================================"
    echo -e "${NC}"
}

print_usage() {
    print_banner
    cat << EOF
${BLUE}Usage:${NC}
  $SCRIPT_NAME <input_script> [output_format]

${BLUE}Output Formats:${NC}
  sh, bash     - Unix/Linux/Mac shell script
  bat          - Windows batch file
  ps1          - PowerShell script
  auto         - Auto-detect and convert to opposite (default)

${BLUE}Examples:${NC}
  $SCRIPT_NAME my_script.bat          # Convert .bat to .sh
  $SCRIPT_NAME my_script.sh bat       # Convert .sh to .bat
  $SCRIPT_NAME my_script.ps1 bash     # Convert .ps1 to .sh

${BLUE}Supported Conversions:${NC}
  .bat → .sh   (Windows Batch to Unix Shell)
  .ps1 → .sh   (PowerShell to Unix Shell)
  .sh  → .bat  (Unix Shell to Windows Batch)
  .sh  → .ps1  (Unix Shell to PowerShell)

EOF
}

# Detect script type from extension
detect_type() {
    local file="$1"
    local ext="${file##*.}"

    case "${ext,,}" in
        bat|cmd) echo "bat" ;;
        ps1) echo "ps1" ;;
        sh|bash) echo "sh" ;;
        *) echo "unknown" ;;
    esac
}

# Convert .bat to .sh
bat_to_sh() {
    local input="$1"
    local output="$2"

    echo -e "${BLUE}Converting .bat → .sh${NC}"

    cat > "$output" << 'HEADER'
#!/bin/bash
#
# Converted from Windows .bat script
# Generated by Script Porter v1.0
#

HEADER

    # Process line by line
    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Convert comments
        if [[ "$line" =~ ^[[:space:]]*REM || "$line" =~ ^[[:space:]]*:: ]]; then
            echo "# ${line#*REM}" | sed 's/^# ::/# /' >> "$output"
            continue
        fi

        # Convert common Windows commands to Unix equivalents
        local converted="$line"

        # ECHO → echo
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*ECHO[[:space:]]+/echo /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*echo[[:space:]]+OFF/# echo off (not needed in bash)/')

        # PAUSE → read
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*PAUSE/read -p "Press Enter to continue..."/')

        # CLS → clear
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*CLS/clear/')

        # SET → export (for environment variables)
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*SET[[:space:]]+([A-Za-z0-9_]+)=/export \1=/')

        # CD → cd
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*CD[[:space:]]+/cd /')

        # DEL → rm
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*DEL[[:space:]]+/rm -f /')

        # COPY → cp
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*COPY[[:space:]]+/cp /')

        # MOVE → mv
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*MOVE[[:space:]]+/mv /')

        # MD/MKDIR → mkdir
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*MD[[:space:]]+/mkdir -p /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*MKDIR[[:space:]]+/mkdir -p /')

        # RD/RMDIR → rmdir
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*RD[[:space:]]+/rmdir /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*RMDIR[[:space:]]+/rmdir /')

        # TYPE → cat
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*TYPE[[:space:]]+/cat /')

        # %variable% → $variable
        converted=$(echo "$converted" | sed -E 's/%([A-Za-z0-9_]+)%/$\1/g')

        # IF EXIST → if [ -e ... ]
        if [[ "$converted" =~ IF[[:space:]]+EXIST ]]; then
            converted=$(echo "$converted" | sed -E 's/IF[[:space:]]+EXIST[[:space:]]+([^[:space:]]+)/if [ -e \1 ]; then/')
            echo "$converted" >> "$output"
            echo "    # Converted IF EXIST block - add your logic here" >> "$output"
            echo "fi" >> "$output"
            continue
        fi

        # GOTO → function (commented warning)
        if [[ "$converted" =~ GOTO ]]; then
            echo "# WARNING: GOTO not supported in bash - refactor needed" >> "$output"
            echo "# Original: $line" >> "$output"
            continue
        fi

        # Write converted line
        [[ -n "$converted" ]] && echo "$converted" >> "$output"

    done < "$input"

    # Make executable
    chmod +x "$output"

    echo -e "${GREEN}✓ Conversion complete: $output${NC}"
    echo -e "${YELLOW}⚠ Note: Complex batch logic may need manual adjustment${NC}"
}

# Convert .ps1 to .sh
ps1_to_sh() {
    local input="$1"
    local output="$2"

    echo -e "${BLUE}Converting .ps1 → .sh${NC}"

    cat > "$output" << 'HEADER'
#!/bin/bash
#
# Converted from PowerShell .ps1 script
# Generated by Script Porter v1.0
#

HEADER

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Convert comments
        if [[ "$line" =~ ^[[:space:]]*# ]]; then
            echo "$line" >> "$output"
            continue
        fi

        local converted="$line"

        # Write-Host → echo
        converted=$(echo "$converted" | sed -E 's/Write-Host[[:space:]]+/echo /')

        # Get-Content → cat
        converted=$(echo "$converted" | sed -E 's/Get-Content[[:space:]]+/cat /')

        # Set-Location → cd
        converted=$(echo "$converted" | sed -E 's/Set-Location[[:space:]]+/cd /')

        # Remove-Item → rm
        converted=$(echo "$converted" | sed -E 's/Remove-Item[[:space:]]+/rm -rf /')

        # Copy-Item → cp
        converted=$(echo "$converted" | sed -E 's/Copy-Item[[:space:]]+/cp -r /')

        # Move-Item → mv
        converted=$(echo "$converted" | sed -E 's/Move-Item[[:space:]]+/mv /')

        # New-Item → mkdir or touch
        converted=$(echo "$converted" | sed -E 's/New-Item[[:space:]]+-ItemType[[:space:]]+Directory/mkdir -p/')

        # Test-Path → [ -e ... ]
        converted=$(echo "$converted" | sed -E 's/Test-Path[[:space:]]+/[ -e /')

        # $variables (keep as-is mostly)
        # PowerShell $var → bash $var (already compatible)

        [[ -n "$converted" ]] && echo "$converted" >> "$output"

    done < "$input"

    chmod +x "$output"

    echo -e "${GREEN}✓ Conversion complete: $output${NC}"
    echo -e "${YELLOW}⚠ Note: PowerShell objects/cmdlets may need manual conversion${NC}"
}

# Convert .sh to .bat
sh_to_bat() {
    local input="$1"
    local output="$2"

    echo -e "${BLUE}Converting .sh → .bat${NC}"

    cat > "$output" << 'HEADER'
@echo off
REM Converted from Unix shell script
REM Generated by Script Porter v1.0
REM

HEADER

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Skip shebang
        [[ "$line" =~ ^#! ]] && continue

        # Convert comments
        if [[ "$line" =~ ^[[:space:]]*# ]]; then
            echo "REM ${line#*#}" >> "$output"
            continue
        fi

        local converted="$line"

        # echo → ECHO
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*echo[[:space:]]+/ECHO /')

        # read → PAUSE or SET /P
        if [[ "$converted" =~ read.*-p ]]; then
            prompt=$(echo "$converted" | sed -E 's/.*-p[[:space:]]+"([^"]+)".*/\1/')
            converted="PAUSE REM $prompt"
        else
            converted=$(echo "$converted" | sed -E 's/^[[:space:]]*read/PAUSE/')
        fi

        # clear → CLS
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*clear/CLS/')

        # export → SET
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*export[[:space:]]+/SET /')

        # cd → CD
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cd[[:space:]]+/CD /')

        # rm → DEL
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*rm[[:space:]]+-[rf]+[[:space:]]+/DEL \/Q /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*rm[[:space:]]+/DEL /')

        # cp → COPY
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cp[[:space:]]+/COPY /')

        # mv → MOVE
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*mv[[:space:]]+/MOVE /')

        # mkdir → MD or MKDIR
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*mkdir[[:space:]]+-p[[:space:]]+/MKDIR /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*mkdir[[:space:]]+/MKDIR /')

        # cat → TYPE
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cat[[:space:]]+/TYPE /')

        # $variable → %variable%
        converted=$(echo "$converted" | sed -E 's/\$([A-Za-z0-9_]+)/%\1%/g')

        # if [ -e ... ] → IF EXIST
        if [[ "$converted" =~ if[[:space:]]*\[[[:space:]]*-e ]]; then
            file=$(echo "$converted" | sed -E 's/.*-e[[:space:]]+([^]]+).*/\1/')
            converted="IF EXIST $file ("
            echo "$converted" >> "$output"
            echo "    REM Add your logic here" >> "$output"
            echo ")" >> "$output"
            continue
        fi

        # Functions warning
        if [[ "$line" =~ ^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*\(\) ]]; then
            echo "REM WARNING: Functions need to be converted to subroutines" >> "$output"
            echo "REM Original: $line" >> "$output"
            continue
        fi

        [[ -n "$converted" ]] && echo "$converted" >> "$output"

    done < "$input"

    echo -e "${GREEN}✓ Conversion complete: $output${NC}"
    echo -e "${YELLOW}⚠ Note: Complex bash logic may need manual adjustment${NC}"
}

# Convert .sh to .ps1
sh_to_ps1() {
    local input="$1"
    local output="$2"

    echo -e "${BLUE}Converting .sh → .ps1${NC}"

    cat > "$output" << 'HEADER'
# Converted from Unix shell script
# Generated by Script Porter v1.0

HEADER

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Skip shebang
        [[ "$line" =~ ^#! ]] && continue

        # Comments (keep as-is)
        if [[ "$line" =~ ^[[:space:]]*# ]]; then
            echo "$line" >> "$output"
            continue
        fi

        local converted="$line"

        # echo → Write-Host
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*echo[[:space:]]+/Write-Host /')

        # cat → Get-Content
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cat[[:space:]]+/Get-Content /')

        # cd → Set-Location
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cd[[:space:]]+/Set-Location /')

        # rm → Remove-Item
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*rm[[:space:]]+-rf[[:space:]]+/Remove-Item -Recurse -Force /')
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*rm[[:space:]]+/Remove-Item /')

        # cp → Copy-Item
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*cp[[:space:]]+/Copy-Item /')

        # mv → Move-Item
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*mv[[:space:]]+/Move-Item /')

        # mkdir → New-Item
        converted=$(echo "$converted" | sed -E 's/^[[:space:]]*mkdir[[:space:]]+-p[[:space:]]+/New-Item -ItemType Directory -Force -Path /')

        # Variables stay as $var (compatible)

        [[ -n "$converted" ]] && echo "$converted" >> "$output"

    done < "$input"

    echo -e "${GREEN}✓ Conversion complete: $output${NC}"
    echo -e "${YELLOW}⚠ Note: Bash-specific features may need PowerShell equivalents${NC}"
}

# Main execution
main() {
    if [[ "$1" == "--help" || "$1" == "-h" || -z "$1" ]]; then
        print_usage
        exit 0
    fi

    local input_file="$1"
    local output_format="${2:-auto}"

    # Check input file exists
    if [[ ! -f "$input_file" ]]; then
        echo -e "${RED}✗ Error: Input file not found: $input_file${NC}"
        exit 1
    fi

    print_banner

    # Detect input type
    local input_type=$(detect_type "$input_file")

    if [[ "$input_type" == "unknown" ]]; then
        echo -e "${RED}✗ Error: Unknown input file type${NC}"
        echo "Supported: .bat, .ps1, .sh"
        exit 1
    fi

    echo -e "${BLUE}Input:${NC} $input_file (type: $input_type)"

    # Determine output format
    local target_format="$output_format"
    if [[ "$output_format" == "auto" ]]; then
        case "$input_type" in
            bat|ps1) target_format="sh" ;;
            sh) target_format="bat" ;;
        esac
    fi

    # Normalize format names
    case "${target_format,,}" in
        bash) target_format="sh" ;;
        cmd) target_format="bat" ;;
    esac

    echo -e "${BLUE}Output format:${NC} $target_format"

    # Generate output filename
    local base_name="${input_file%.*}"
    local output_file=""

    case "$target_format" in
        sh) output_file="${base_name}.sh" ;;
        bat) output_file="${base_name}.bat" ;;
        ps1) output_file="${base_name}.ps1" ;;
        *)
            echo -e "${RED}✗ Error: Unsupported output format: $target_format${NC}"
            exit 1
            ;;
    esac

    # Prevent overwriting input
    if [[ "$output_file" == "$input_file" ]]; then
        output_file="${base_name}_converted.${target_format}"
    fi

    echo -e "${BLUE}Output:${NC} $output_file"
    echo ""

    # Perform conversion
    case "$input_type-$target_format" in
        bat-sh)
            bat_to_sh "$input_file" "$output_file"
            ;;
        ps1-sh)
            ps1_to_sh "$input_file" "$output_file"
            ;;
        sh-bat)
            sh_to_bat "$input_file" "$output_file"
            ;;
        sh-ps1)
            sh_to_ps1 "$input_file" "$output_file"
            ;;
        *)
            echo -e "${RED}✗ Error: Conversion $input_type → $target_format not supported${NC}"
            exit 1
            ;;
    esac

    echo ""
    echo -e "${GREEN}========================================"
    echo "   Conversion Complete!"
    echo "========================================${NC}"
    echo ""
    echo "Next steps:"
    echo "1. Review the converted script: $output_file"
    echo "2. Test on target platform"
    echo "3. Adjust any platform-specific logic"
    echo ""
}

main "$@"
